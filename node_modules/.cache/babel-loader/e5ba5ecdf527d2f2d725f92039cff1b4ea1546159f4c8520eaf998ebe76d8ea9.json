{"ast":null,"code":"'use strict';\n\n/**\n * Module dependencies\n */\nvar Emitter = require('events').EventEmitter;\nvar sliced = require('sliced');\nvar debug = require('debug')('nightmare:ipc');\n\n// If this process has a parent, redirect debug logs to it\nif (process.send) {\n  debug = function () {\n    process.send(['nightmare:ipc:debug'].concat(sliced(arguments)));\n  };\n}\n\n/**\n * Export `IPC`\n */\n\nmodule.exports = IPC;\n\n/**\n * Initialize `IPC`\n */\n\nvar instance = Symbol();\nfunction IPC(process) {\n  if (process[instance]) {\n    return process[instance];\n  }\n  var emitter = process[instance] = new Emitter();\n  var emit = emitter.emit;\n  var callId = 0;\n  var responders = {};\n\n  // no parent\n  if (!process.send) {\n    return emitter;\n  }\n  process.on('message', function (data) {\n    // handle debug logging specially\n    if (data[0] === 'nightmare:ipc:debug') {\n      debug.apply(null, sliced(data, 1));\n    }\n    emit.apply(emitter, sliced(data));\n  });\n  emitter.emit = function () {\n    if (process.connected) {\n      process.send(sliced(arguments));\n    }\n  };\n\n  /**\n   * Call a responder function in the associated process. (In the process,\n   * responders can be registered with `ipc.respondTo()`.) The last argument\n   * should be a callback function, which will called with the results of the\n   * responder.\n   * This returns an event emitter. You can listen for the results of the\n   * responder using the `end` event (this is the same as passing a callback).\n   * Additionally, you can listen for `data` events, which the responder may\n   * send to indicate some sort of progress.\n   * @param  {String} name Name of the responder function to call\n   * @param  {...Objects} [arguments] Any number of arguments to send\n   * @param  {Function} [callback] A callback function that handles the results\n   * @return {Emitter}\n   */\n  emitter.call = function (name) {\n    var args = sliced(arguments, 1);\n    var callback = args.pop();\n    if (typeof callback !== 'function') {\n      args.push(callback);\n      callback = undefined;\n    }\n    var id = callId++;\n    var progress = new Emitter();\n    emitter.on(`CALL_DATA_${id}`, function () {\n      progress.emit.apply(progress, ['data'].concat(sliced(arguments)));\n    });\n    emitter.once(`CALL_RESULT_${id}`, function (err) {\n      // unserialize errors\n      err = unserializeError(err);\n      progress.emit.apply(progress, ['end'].concat(err).concat(sliced(arguments, 1)));\n      emitter.removeAllListeners(`CALL_DATA_${id}`);\n      progress.removeAllListeners();\n      progress = undefined;\n      if (callback) {\n        callback.apply(null, [err].concat(sliced(arguments, 1)));\n      }\n    });\n    emitter.emit.apply(emitter, ['CALL', id, name].concat(args));\n    return progress;\n  };\n\n  /**\n   * Register a responder to be called from other processes with `ipc.call()`.\n   * The responder should be a function that accepts any number of arguments,\n   * where the last argument is a callback function. When the responder has\n   * finished its work, it MUST call the callback. The first argument should be\n   * an error, if any, and the second should be the results.\n   * Only one responder can be registered for a given name.\n   * @param {String} name The name to register the responder under.\n   * @param {Function} responder\n   */\n  emitter.respondTo = function (name, responder) {\n    if (responders[name]) {\n      debug(`Replacing responder named \"${name}\"`);\n    }\n    responders[name] = responder;\n  };\n  emitter.on('CALL', function (id, name) {\n    var responder = responders[name];\n    var done = function (err) {\n      err = serializeError(err);\n      emitter.emit.apply(emitter, [`CALL_RESULT_${id}`].concat(err).concat(sliced(arguments, 1)));\n    };\n    done.progress = function () {\n      emitter.emit.apply(emitter, [`CALL_DATA_${id}`].concat(sliced(arguments)));\n    };\n    if (!responder) {\n      return done(new Error(`Nothing responds to \"${name}\"`));\n    }\n    try {\n      responder.apply(null, sliced(arguments, 2).concat([done]));\n    } catch (error) {\n      done(error);\n    }\n  });\n  return emitter;\n}\nfunction serializeError(err) {\n  if (!(err instanceof Error)) return err;\n  return {\n    code: err.code,\n    message: err.message,\n    details: err.detail,\n    stack: err.stack || ''\n  };\n}\nfunction unserializeError(err) {\n  if (!err || !err.message) return err;\n  const e = new Error(err.message);\n  e.code = err.code || -1;\n  if (err.stack) e.stack = err.stack;\n  if (err.details) e.details = err.details;\n  if (err.url) e.url = err.url;\n  return e;\n}","map":{"version":3,"names":["Emitter","require","EventEmitter","sliced","debug","process","send","concat","arguments","module","exports","IPC","instance","Symbol","emitter","emit","callId","responders","on","data","apply","connected","call","name","args","callback","pop","push","undefined","id","progress","once","err","unserializeError","removeAllListeners","respondTo","responder","done","serializeError","Error","error","code","message","details","detail","stack","e","url"],"sources":["/Users/nicolecheung/my-recipes/node_modules/nightmare/lib/ipc.js"],"sourcesContent":["'use strict'\n\n/**\n * Module dependencies\n */\n\nvar Emitter = require('events').EventEmitter\nvar sliced = require('sliced')\nvar debug = require('debug')('nightmare:ipc')\n\n// If this process has a parent, redirect debug logs to it\nif (process.send) {\n  debug = function() {\n    process.send(['nightmare:ipc:debug'].concat(sliced(arguments)))\n  }\n}\n\n/**\n * Export `IPC`\n */\n\nmodule.exports = IPC\n\n/**\n * Initialize `IPC`\n */\n\nvar instance = Symbol()\nfunction IPC(process) {\n  if (process[instance]) {\n    return process[instance]\n  }\n\n  var emitter = (process[instance] = new Emitter())\n  var emit = emitter.emit\n  var callId = 0\n  var responders = {}\n\n  // no parent\n  if (!process.send) {\n    return emitter\n  }\n\n  process.on('message', function(data) {\n    // handle debug logging specially\n    if (data[0] === 'nightmare:ipc:debug') {\n      debug.apply(null, sliced(data, 1))\n    }\n    emit.apply(emitter, sliced(data))\n  })\n\n  emitter.emit = function() {\n    if (process.connected) {\n      process.send(sliced(arguments))\n    }\n  }\n\n  /**\n   * Call a responder function in the associated process. (In the process,\n   * responders can be registered with `ipc.respondTo()`.) The last argument\n   * should be a callback function, which will called with the results of the\n   * responder.\n   * This returns an event emitter. You can listen for the results of the\n   * responder using the `end` event (this is the same as passing a callback).\n   * Additionally, you can listen for `data` events, which the responder may\n   * send to indicate some sort of progress.\n   * @param  {String} name Name of the responder function to call\n   * @param  {...Objects} [arguments] Any number of arguments to send\n   * @param  {Function} [callback] A callback function that handles the results\n   * @return {Emitter}\n   */\n  emitter.call = function(name) {\n    var args = sliced(arguments, 1)\n    var callback = args.pop()\n    if (typeof callback !== 'function') {\n      args.push(callback)\n      callback = undefined\n    }\n\n    var id = callId++\n    var progress = new Emitter()\n\n    emitter.on(`CALL_DATA_${id}`, function() {\n      progress.emit.apply(progress, ['data'].concat(sliced(arguments)))\n    })\n\n    emitter.once(`CALL_RESULT_${id}`, function(err) {\n      // unserialize errors\n      err = unserializeError(err)\n\n      progress.emit.apply(\n        progress,\n        ['end'].concat(err).concat(sliced(arguments, 1))\n      )\n\n      emitter.removeAllListeners(`CALL_DATA_${id}`)\n      progress.removeAllListeners()\n      progress = undefined\n      if (callback) {\n        callback.apply(null, [err].concat(sliced(arguments, 1)))\n      }\n    })\n\n    emitter.emit.apply(emitter, ['CALL', id, name].concat(args))\n    return progress\n  }\n\n  /**\n   * Register a responder to be called from other processes with `ipc.call()`.\n   * The responder should be a function that accepts any number of arguments,\n   * where the last argument is a callback function. When the responder has\n   * finished its work, it MUST call the callback. The first argument should be\n   * an error, if any, and the second should be the results.\n   * Only one responder can be registered for a given name.\n   * @param {String} name The name to register the responder under.\n   * @param {Function} responder\n   */\n  emitter.respondTo = function(name, responder) {\n    if (responders[name]) {\n      debug(`Replacing responder named \"${name}\"`)\n    }\n    responders[name] = responder\n  }\n\n  emitter.on('CALL', function(id, name) {\n    var responder = responders[name]\n    var done = function(err) {\n      err = serializeError(err)\n      emitter.emit.apply(\n        emitter,\n        [`CALL_RESULT_${id}`].concat(err).concat(sliced(arguments, 1))\n      )\n    }\n    done.progress = function() {\n      emitter.emit.apply(emitter, [`CALL_DATA_${id}`].concat(sliced(arguments)))\n    }\n    if (!responder) {\n      return done(new Error(`Nothing responds to \"${name}\"`))\n    }\n    try {\n      responder.apply(null, sliced(arguments, 2).concat([done]))\n    } catch (error) {\n      done(error)\n    }\n  })\n\n  return emitter\n}\n\nfunction serializeError(err) {\n  if (!(err instanceof Error)) return err\n  return {\n    code: err.code,\n    message: err.message,\n    details: err.detail,\n    stack: err.stack || ''\n  }\n}\n\nfunction unserializeError(err) {\n  if (!err || !err.message) return err\n  const e = new Error(err.message)\n  e.code = err.code || -1\n  if (err.stack) e.stack = err.stack\n  if (err.details) e.details = err.details\n  if (err.url) e.url = err.url\n  return e\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}